%Book
%Copyright (C) 2019  Patrick Diehl
%
%This program is free software: you can redistribute it and/or modify
%it under the terms of the GNU General Public License as published by
%the Free Software Foundation, either version 3 of the License, or
%(at your option) any later version.

%This program is distributed in the hope that it will be useful,
%but WITHOUT ANY WARRANTY; without even the implied warranty of
%MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%GNU General Public License for more details.

%You should have received a copy of the GNU General Public License
%along with this program.  If not, see <http://www.gnu.org/licenses/>.

%\chapterimage{chapter_head_2.pdf} % Chapter heading image

%----------------------------------------------------------------------------------------
\chapter{Introduction C++}
%----------------------------------------------------------------------------------------
This chapter introduces the core features of the C++ language. Specifically, we focus on introducing the C++ standard template library (see Section~\ref{chapter:stl}), which is essential for implementing mathematical equations and algorithms. Let us briefly look into this library so that we may implement the numerical examples in Part~\ref{part:numerical:examples}. For more details we refer to
\begin{itemize}
\item \fullcite{andrew2000accelerated}
\end{itemize}
since this book gives an excellent pragmatic overview with many examples. For even more C++ basics, we refer to
\begin{itemize}
\item \fullcite{stroustrup2014programming}.
\end{itemize}
%----------------------------------------------------------------------------------------
\section{History of C and C++}
%----------------------------------------------------------------------------------------
The development of the programming language \texttt{C} started in 1972 as an improvement of the language \texttt{B}\link{https://en.wikipedia.org/wiki/B_(programming_language)} language~\cite{ritchie1993development}. In 1978 the book by Dennis Ritchie and Brian Kernighan \textit{The C Programming Language}~\cite{kernighan2006c} became known as the informal specification of the \texttt{C} language. In contrast to the simple and small standard library, \texttt{C} compilers varied widely and had no standards. The American National Standards Institute (ANSI) began writing the \texttt{C} standard based on the Unix implementation of the language. This later became the foundation of the 1988 POSIX\link{https://en.wikipedia.org/wiki/POSIX} standard. One year later, the \texttt{C} standard was published as ANSI X3.159-1989 "Programming Language C." More common names for this version are ANSI C or C89. The International Organization of Standardization (ISO) adopted the ANSI C specification and published it as ISO/IEC 9899:1990, which is called C90. Note that C90 and C89 refer to the same standard. This standard was revised in the 1990s and published as ISO/IEC 9899:1999 in 1999 which is the C99 standard. In 2007 the C11 standard was published and in 2018 the C18 standard.\\

Concurrently, in 1979, Bajarne Stroustrup began developing "C with classes"\link{http://www.stroustrup.com/bs_faq.html\#invention}, which later became \texttt{C++}. Stroustrup added classes, derived classes, inlining, and default arguments to the \texttt{C} compiler~\cite{stroustrup1996history}. The name \texttt{C++} symbolizes the increment of \texttt{C} using the increment operator \cpp{++}. The \texttt{C++} Programming Language launched in 1985, though without an official standard~\cite{stroustrup2000c++}. Updated and standardized versions followed: In 1998 C++98~\cite{koenig1998standard}; In 1999 C++ 2.0; In 2003 C++03~\cite{c++2003iso}; In 2011 C++11~\cite{c++2011iso}; In 2014 C++14~\cite{c++2014iso}. The latest standard is C++17~\cite{smith2017iso}, and the upcoming one is C++20.

%----------------------------------------------------------------------------------------
\section{Getting started with C++}
%----------------------------------------------------------------------------------------
To begin with C++ programming, we look at a simple C++ program: the classic''Hello World'' example. Listing~\ref{code:hello:world} shows this program. The first line in green is a comment. Single-line comments start with \lstinline[language=C++]|//|. Programmers often use them to explain the functionality of the program or the next lines of code. Once may also use multi-line comments\endnote{\url{https://en.cppreference.com/w/cpp/comment}} by enclosing the text within \lstinline[language=C++]{/* */}. Comment early and often; comments are crucial for readability and clarity of the program, especially if the code is shared with other collaborators. Fore more details refer to~\cite{kernighan1974elements}.

The second line starts with a so-called include directive\endnote{\url{https://en.cppreference.com/w/cpp/preprocessor/include}} \lstinline[language=C++]{#include <iostream>}. This include directive incorporates functionality of the C++ standard library (see Chpater~\ref{chapter:stl}). In our case we include the \lstinline|iostream| header so that we may print "Hello World" to the terminal (see Line 6).

The fourth line \lstinline[language=C++]{int main()} starts with the Main function\endnote{\url{https://en.cppreference.com/w/cpp/language/main_function}}, which is the entry point of the program. This means all subsequent lines are executed sequentially. Every C++ program which will be compiled to an executable file needs exactly one function called \lstinline[language=C++]|main|, which has an integer \lstinline[language=C++]{int} as its return type. On most operating systems a return value of zero means that the program executed successfully, and any other value (often 1 or -1) indicates a failure. The second-to-last line \lstinline[]|return| is the return statement\endnote{\url{https://en.cppreference.com/w/cpp/language/return}}, which must match the return type in front of the \lstinline[language=C++]{int main()}.


\lstinputlisting[language=C++,caption={A simple C++ program, the so-called ``Hello World'' example.\label{code:hello:world}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture1-main.cpp}

Once we have written the program, we have to compile the C++ code into an executable so that we can run the code and print ``Hello world'' to the terminal. There are a plethora of C++ compilers\endnote{\url{https://en.wikipedia.org/wiki/List_of_compilers\#C++_compilers}} available, but this book will use the GNU Compiler Collection (GCC) for all examples. Line 1 in Listing~\ref{code:hello:world:compile} shows how to compile the file \lstinline[language=bash]|lecture1-1.cpp|, which contains the C++ code in Listing~\ref{code:hello:world}, to an executable. GCC provides the \lstinline[language=bash]{g++} compiler to compile C++ code and the \lstinline[language=bash]{gcc} compiler for C code. As the first argument to the \lstinline[language=bash]{g++} compiler, we enter the C++ file name and add the \lstinline[language=bash]|-o| option to specify the name of the executable. To run the generated executable, we type \lstinline[language=bash]|./lecture-1-1| in the terminal. For basic usage of the Linux terminal refer to~\cite{newham2005learning,robbins2016bash}.

\lstinputlisting[language=bash,caption={Compilation and execution of the C++ program.\label{code:hello:world:compile}},float,floatplacement=tb,firstline=2, lastline=3]{ParallelComputationMathExamples/chapter2/lecture1-main.sh}

\begin{exercise}
Download the example program\endnote{\url{https://github.com/diehlpkteaching/ParallelComputationMathExamples}} from GitHub and compile it with your favorite C++ compiler. After running the example you can try to modify it--For example you could print a different text or add a second line to the output.
\end{exercise}


%----------------------------------------------------------------------------------------
\section{Fundamental data types}
\label{sec:fundamental:types}
%----------------------------------------------------------------------------------------
\index{data types!fundamental}
In this section we introduce the fundamental data types\endnote{\url{https://en.cppreference.com/w/cpp/language/types}} provided by the C++ language. First, the numeric data types. To represent natural numbers $\mathbb{N}=\{0,1,2,\ldots \}$ the \lstinline[language=C++]|unsigned int| data type is available. To represent integer numbers $\mathbb{Z}=\{\ldots,-2,-1,0,1,2,\ldots \}$ the \lstinline[language=C++]|int| data type is available. For these data types we can apply the following sizes: \lstinline[language=C++]|short|, \lstinline[language=C++]|long|, and \lstinline[language=C++]|long long|. In the \cpp{#include <climits>}\link{https://en.cppreference.com/w/cpp/header/climits} header the minimal and maximal value of all integer data types are defined. For example the minimal value of \cpp{int} data type is given by \cpp{INT_MIN} and the maximal value by \cpp{INT_MAX}, respectively. For more details about the binary numeral system, refer to~\cite{gilli1965binary}. 

To represent real numbers $\mathbb{R}$ the \lstinline[language=C++]|float| data type and \lstinline[language=C++]|double| data type are available. In the \cpp{#include <cfloat>}\link{https://en.cppreference.com/w/cpp/header/cfloat} header the minimal and maximal value of all floating point data types are defined. For example the minimal value of \cpp{double} data type is given by \cpp{DBL_MIN} and the maximal value by \cpp{DBL_MAX}, respectively. 

Fore more details about the IEEE 474 standard for how floating point numbers are represented in the computer, refer to~\cite{4610935,goldberg1991every}. Table~\ref{chapter2:table:datatypes} summarizes all the available numeric data types and their ranges. The next section shows how to get the range of the IEEE 474 standard for floating point numbers.

\begin{table}[h]
\centering
\begin{tabular}{lccc}
\toprule
Data type & Size (Bytes) & Min & Max \\\midrule
\multicolumn{4}{c}{Natural numbers $\mathbb{N}$ }\\\midrule
\lstinline[language=C++]|unsigned short int| & 2 & 0 & 65,535  \\ 
\lstinline[language=C++]|unsigned int| & 4 & 0 & 4,294,967,295 \\ 
\lstinline[language=C++]|unsigned long int| & 4 & 0 & 4,294,967,295 \\ 
\lstinline[language=C++]|unsigned long long int| & 8 & 0 & 8,446,744,073,709,551,615 \\ \midrule
\multicolumn{4}{c}{Integer numbers $\mathbb{Z}$ }\\\midrule
\lstinline[language=C++]|short int| & 2 & -32,768 & 32,768 \\
\lstinline[language=C++]|int| & 4 & -2,147,483,648 & 2,147,483,648 \\
\lstinline[language=C++]|long long int| & 8 & $-2^{63}$ & $2^{63}-1$ \\\midrule
\multicolumn{4}{c}{Real numbers $\mathbb{R}$ }\\\midrule
\lstinline[language=C++]|float| & 4 &  &  \\
\lstinline[language=C++]|double| & 8 &  &  \\
\bottomrule
\end{tabular} 
\caption{Overview of the fundamental numeric data types.}
\label{chapter2:table:datatypes}
\end{table}

To represent a boolean value we use the $\mathbf{B}=\{0,1\}$ the \lstinline[language=C++]|bool| data type which has exactly one of the two available values, \lstinline[language=C++]|true| or \lstinline[language=C++]|false|. Note that the C++ STL offers \lstinline|std::complex|\endnote{\url{https://en.cppreference.com/w/cpp/numeric/complex}} for complex numbers $\mathbb{C}$, however, this one is not within the fundamental data types.

%----------------------------------------------------------------------------------------
\section{Statements and flow control}
%----------------------------------------------------------------------------------------

%----------------------------------------------------------------------------------------
\subsection{Iteration statements}
\label{sec:iteration:statements}
%----------------------------------------------------------------------------------------
\index{statements!iteration} For some applications, we have to repeat an instruction or group of instructions multiple times. The C++ language provides two iteration statements: the \lstinline[language=C++]|for| loop and the \lstinline[language=C++]|while| loop. Let us look how to compute the sum of the numbers from 1 up to $n$
\begin{align}
r = \sum\limits_{i=1}^n i\text{.}
\end{align}
The first solution uses a \lstinline[language=C++]|for| loop statement\endnote{\url{https://en.cppreference.com/w/cpp/language/for}}\index{loop!for statement}, which is shown in Listing~\ref{code:for:loop}. Line 9 shows the \lstinline[language=C++]|for| loop statement with its three arguments. First, the so--called loop variable \lstinline[language=C++]{size_t i = 0} which is initialized to zero. Note that the loop variable is only defined within the loop's body (The part between the curly braces). Second, the condition statement \lstinline[language=C++]{i < n}, which means that the loop body is repeated until the variable $i$ is equal to or larger than $n$. The third statement manipulates the loop variable. In our case the loop variable is incremented by one after each execution of the loop body. Note that we use the \lstinline[language=C++]|for| loop statement if we know in advance exactly how many times we want to repeat a block of code.


\lstinputlisting[language=C++,caption={Computation of the sum from 1 up to $n$ using the for loop statement. \label{code:for:loop}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture1-for.cpp}

The second option employs a \lstinline[language=C++]|while| loop statement\endnote{\url{https://en.cppreference.com/w/cpp/language/while}}\index{loop!while statement}, which is shown in Listing~\ref{code:while:loop}. Line 10 shows the \lstinline[language=C++]|while| loop statement with its one argument. This is the condition statement  \lstinline[language=C++]{i < n}, which means that the loop body is repeated until the variable $i$ is equal to or larger than $n$. Note in the previous example we had three arguments. In this case the loop variable is declared before the loop in Line 9, and the third statement appears in Line 13 where the loop variable is incremented by one in each iteration. Note that we use the \lstinline[language=C++]|while| loop statement, if we do not know the number of iterations in advance. This example demonstrates that we can write every \lstinline[language=C++]|for| loop statement as a \lstinline[language=C++]|while| loop statement. For more details we refer to~\cite[Chapter~2]{andrew2000accelerated}.   


\lstinputlisting[language=C++,caption={Computation of the sum from 1 up to $n$ using the while loop statement..\label{code:while:loop}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture1-while.cpp}

\begin{exercise}
Explain in your own words in which cases you should use a \lstinline[language=C++]|for| loop statement and a \lstinline[language=C++]|while| loop statement. 
\end{exercise}

%----------------------------------------------------------------------------------------
\subsection{Selection statements}
%----------------------------------------------------------------------------------------
\index{statements!selection}
For some applications, different sections of code should run depending on certain conditions. Equation~\ref{eq:chapter2:if} shows how to compute the sum from 1 to $n$ with different cases for even and odd numbers. If the number is even, it is added to the result, but if it is odd, its square is added to the result.
\begin{align}
r = \sum\limits_{i=1}^n f(i) \text{  with  } f(i) = 
\begin{cases}
i, \text{ if } i \text{ is even} \\
i^2, \text{ else}
\end{cases}
\label{eq:chapter2:if}
\end{align}
Listing~\ref{code:example-if} shows the implementation of Equation~\ref{eq:chapter2:if} using a \lstinline[language=c++]{for} loop. The skeleton of the \lstinline[language=c++]{for} loop is identical to the one in Listing~\ref{code:for:loop}, but the \lstinline[language=c++]{if} statement\endnote{\url{https://en.cppreference.com/w/cpp/language/if}} in Line 8 is added to check whether the current number in the series is even or odd. The \lstinline[language=c++]{if} statement takes exactly one argument, the condition statement. If the statement is evaluated as \lstinline[language=c++]{true} the code between \lstinline[language=c++]{if} and \lstinline[language=c++]{else} runs. If the statement is evaluated as \lstinline[language=c++]{false} the code line after \lstinline[language=c++]{else} runs. It is also possible to use \lstinline[language=c++]{else if} after the first \lstinline[language=c++]{if}. \\

\lstinputlisting[language=C++,caption={Computation of the sum from one up to $n$ using the selection statement.\label{code:example-if}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture1-if.cpp}


The second selection statement is the \lstinline[language=c++]{switch} statement\endnote{\url{https://en.cppreference.com/w/cpp/language/switch}}. We use this statement to execute different code branches depending on a single variable. Listing~\ref{code:example-switch} shows one example that writes the name of the color to the standard output. In this case we use an enumeration \lstinline[language=c++]{enum}\endnote{\url{https://en.cppreference.com/w/cpp/language/enum}} to store the colors. The \lstinline[language=c++]{switch} takes one argument and executes the code between the matching \lstinline[language=c++]{case} and the following \lstinline[language=c++]{break}. For more details we refer to~\cite[Chapter~2]{andrew2000accelerated}.  


\lstinputlisting[language=C++,caption={Computation of the sum from one up to $n$ using the selection statement.\label{code:example-switch}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture1-switch.cpp}


%----------------------------------------------------------------------------------------
\section{Operators}
%----------------------------------------------------------------------------------------
\index{Operators}
For the example in Listing~\ref{code:for:loop} we have seen the operator \lstinline[language=C++]|i<n| which is a so--called comparison operator. Next to the comparison operators, C++ language has following operators\endnote{\url{https://en.cppreference.com/w/cpp/language/operator_precedence}}:
\begin{itemize}
\item Comparison operators, see Table~\ref{sec:1:tab:operator:comp},
\item Arithmetic operators, see Table~\ref{sec:1:tab:operator:arithmetic},
\item Logical operators, see Table~\ref{sec:1:tab:operator:logical}, and
\item Assignment operators, see Table~\ref{sec:1:tab:operator:assign},
\end{itemize}
 logical operators, arithmetic, and assignment.

\begin{table}[p]
\centering
\begin{tabular}{clll}
\toprule
Operator & Name  & Example \\ 
\midrule
\lstinline|==| & Equal to & \lstinline|x==y|\\ 
\lstinline|!=| & Not equal & \lstinline|x!=y|\\ 
\lstinline|>| & Greater than & \lstinline|x > y|\\ 
\lstinline|<| & Less than & \lstinline|x < y|\\ 
\lstinline|>=| & Greater than or equal & \lstinline|x >= y|\\ 
\lstinline|<=| & Less than or equal & \lstinline|x <= y|\\ 
\bottomrule 
\end{tabular} 
\caption{Comparison operators}
\label{sec:1:tab:operator:comp}
\index{Operators!comparison}
\end{table}

\begin{table}[p]
\centering
\begin{tabular}{clll}
\toprule
Operator & Name & Description & Example \\ 
\midrule
\lstinline|+| & Addition & Computes the sum of two values & $2+2=4$ \\ 
\lstinline|-| & Subtraction  & Computes the difference of two values & $5-3=2$ \\ 
\lstinline|/| & Division & Divides two values & $6/2=3$ \\ 
\lstinline|*| & Multiplication & Multiplies two values & $2\times2=4$ \\ 
\lstinline|%| & Modulo &  	Returns the division remainder & \lstinline|2%1=0| \\ 
\lstinline|++| & Increments & Add plus one to the value & \lstinline|1++=2|\\ 
\lstinline|--| & Decrements & Subtract one of the value & \lstinline|1--=0|\\ 
\bottomrule 
\end{tabular} 
\caption{Arithmetic operators}
\label{sec:1:tab:operator:arithmetic}
\index{Operators!arithmetic}
\end{table}


\begin{table}[p]
\centering
\begin{tabular}{clll}
\toprule
Operator & Name & Description & Example \\ 
\midrule
\lstinline|&&| & Logical and & Returns \lstinline|true| if both statements are true  & \lstinline| x > 5 && x < 10| \\ 
\lstinline|||| & Logical or  & Returns \lstinline|true| if one statement is true & \lstinline| x > 5 || y < 10| \\ 
\lstinline|!| & Logical not &  Inverse the statement & \lstinline| !(x > 5 && x < 10)| \\ 
\bottomrule 
\end{tabular} 
\caption{Logical operators}
\label{sec:1:tab:operator:logical}
\index{Operators!logical}
\end{table}


\begin{table}[p]
\centering
\begin{tabular}{clll}
\toprule
Operator & Name & Example & Equivalent  \\ 
\midrule
\lstinline|=| & Assignment &   \lstinline| x = 5| &   \lstinline| x = 5 | \\ 
\lstinline|+=| & Plus equal  & \lstinline| x+= 5|  & \lstinline| x = x + 5 | \\ 
\lstinline|-=| & Minus equal & \lstinline| x-= 5|  & \lstinline| x = x - 5 | \\ 
\lstinline|*=| & Multiplication equal &  \lstinline| x*= 5| & \lstinline| x= x * 5| \\ 
\lstinline|/=| & Division equal &  \lstinline| x/= 5| & \lstinline| x= x / 5| \\ 
\lstinline|%=| & Modulo equal &  \lstinline| x%= 5| & \lstinline| x = x % 5| \\ 
\bottomrule 
\end{tabular} 
\caption{Assignment operators}
\label{sec:1:tab:operator:assign}
\index{Operators!assignment}
\end{table}

\begin{exercise}
Write a small C++ program using selection statements and operators to determine if a given year is a lap year. Following logical statements should be implemented: 
\begin{itemize}
	\item   If year is divided by 4 but not by 100, then it is a leap year.
    \item If year is divided by both 100 and 400, then it is a leap year.
    \item If year is divided by 400, then it is a leap year.
    \item And in all other cases, it is not a leap year.
\end{itemize}
\end{exercise}

%----------------------------------------------------------------------------------------
\subsection{Operator overloading}
\index{operator! overloading}
\label{sec:operator:overloading}
%----------------------------------------------------------------------------------------
The operators in the previous section are defined for the fundamental data types, see Section~\ref{sec:fundamental:types}, and for the STL containers, see Section~\ref{sec:containers}, if applicable. However, for own defined \cpp{struct} and \cpp{class} these are not defined and the programmer has to define them. With C++ 17 38 operators can be overloaded and two more operators were added since C++ 20\link{https://en.cppreference.com/w/cpp/language/operators}. Let us look into the \cpp{struct} for the mathematical vector. We refer to Section~\ref{sec:struct} for more details about \cpp{struct} and focus on the overloading of operators in this section.\\

Listing~\ref{code:operator:overloading} shows the definition of the \cpp{struct} vector as a template \cpp{template<typename T>}. For more details, we refer to Section~\ref{sec:generic:programming}. To do some operation like to add two vectors \cpp{vector<double>a;} and \cpp{vector<double>b;} we have to define the operator \cpp{+}. This is done in Line~7 and is similar to the definition of a function. The name of the function has to be \cpp{operator+} since we overload the plus operator. As the argument a second vector \cpp{rhs} in our example the vector \cpp{b} is provided. Since we return a new vector the return type of the function is \cpp{vector<T>}. The values of the new vector are the additions of the vector components. Because we overloaded the plus operator, we can write following expression \cpp{vector<double> c = a+b;}. However, for the expression \cpp{vector<double> c = a-b;} the C++ compiler would report following error ''error: no match for ‘operator-’ (operand types are ‘vector’ and ‘vector’)`` since the minus operator was not overloaded.

\begin{exercise}
Overload the minus and the multiplication operator for the \cpp{struct vector}.
\end{exercise}

In Line~11 the output parameter \cpp{<<} is overloaded to print the coordinate values to the standard output stream. For this operator two arguments are provided. The \cpp{ostream& os} and after this the vector to be printed. In Line~13 the vector coordinates are printed to the output stream with the predefined operator \cpp{<<}. The return type of the operator overload function is of the type \cpp{ostream&}. For this operator overload, the keyword \cpp{friend}\index{friend}\link{https://en.cppreference.com/w/cpp/language/friend} is needed. using the \cpp{friend} declarations allows a function or another class access to private and protected members of the struct.

\begin{lstlisting}[language=c++,caption={Example for the operator overload for the plus operator and the output operator.\label{code:operator:overloading}},float,floatplacement=tb]
template<typename T>
struct vector {
T x;
T y;
T z;
// Overload the addition operator
vector<T> operator+(const vector<T> rhs){
return vector<T>( x + rhs.x, y + rhs.y, z + rhs.z );
}
//Overload the output operator
friend ostream& operator
	<<(ostream& os, const vector<T>& vec)
{
    os << vec.x << " " << vec.y << " " <<  vec.z;
    return os;
}
};
\end{lstlisting}


\begin{exercise}
Overload the input operator \cpp{>>} for the \cpp{struct vector}.
\end{exercise}

%----------------------------------------------------------------------------------------
\section{Structuring source code}
%----------------------------------------------------------------------------------------
For large code bases, we like to organize the code and avoid to have one huge file with thousand of lines. There, C++ provides two fundamental ways to organize the code
\begin{enumerate}
\item To structure the code it self, we can use functions, \emph{e.g.}\ \cpp{double norm()}, and \cpp{struct} or \cpp{class}.
\item To split the code into separated files to make all files shorter and
separate the code by its functionality, we can use the s-called header files and source files.
\end{enumerate}
For more details we refer to~\cite[Chapter~4]{andrew2000accelerated}. Within the computer science, the research area software engineering deals with the aspect how to organize large code bases and make it maintainable. For more details, we refer to~\cite{hunt1900pragmatic,sommerville2011software}. 


%----------------------------------------------------------------------------------------
\subsection{Functions}
\index{functions}
\index{structure!function}
\label{sec:functions}
%----------------------------------------------------------------------------------------
To use code again and do not have to repeat code blocks multiple times, one can use function definitions\link{https://en.cppreference.com/w/c/language/function_definition}. Listings~\ref{code:functions:max} shows the definition of the function \cpp{max}. In Line~1 the return type \cpp{int} of the function is defined which means that this function will return one integer value. This is happening in Line~3 using the \cpp{return}\link{https://en.cppreference.com/w/cpp/language/return} keyword. If the function has no return value, the keyword \cpp{void} is used. In Line~1 the name of the function\link{https://en.cppreference.com/w/cpp/language/functions} \cpp{max} is defined and in the parentheses the function arguments are provided separated by commas. In this example two integer values with the name \cpp{a} and \cpp{b} are provided. For the return value, a short form of the \cpp{if} statement. the so--called conditional operator\link{https://en.cppreference.com/w/cpp/language/operator_other\#Conditional_operator}, is provided which means if $a>b$ return $a$ and else return $b$. The function is called as \cpp{double result = max(5,7.7)}.   \\

\begin{lstlisting}[language=c++,caption={Example for a function definition to compute the maximum of two numbers.\label{code:functions:max}},float,floatplacement=tb]
int max(int a, int b)
{
return a>b?a:b;
}
\end{lstlisting}

Function are defined between \cpp{#include} and \cpp{int main (void)} in the source code file. Listing~\ref{code:example-function} shows the usage of a function definition for the example in Equation~\ref{eq:chapter2:if}. For more details we refer to~\cite[Chapter~4]{andrew2000accelerated}.

\lstinputlisting[language=C++,caption={Example for a function definition to compute Equation~\ref{eq:chapter2:if}.\label{code:example-function}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture2-function.cpp}


%----------------------------------------------------------------------------------------
\subsection{Struct}
\index{struct}
\index{structure!struct}
\label{sec:struct}
%----------------------------------------------------------------------------------------
In some case, we like to group data, for example to represent a vector $v=(x,y,z)^T\in \mathbb{R}^3$. Here, the \cpp{struct}\link{https://en.cppreference.com/w/c/language/struct} expression is provided. Note that the struct was introduced in the C language and its companion in the C++ language is the \cpp{class} expression. However, to make the C language a subset of the C++ language, the \cpp{struct} is still available. Listing~\ref{code:struct} shows the struct with the three variables for each direction of the vector space. To declare a vector, we just write \cpp{struct vector v} to have an vector with the name \cpp{v} and to initialize the vector with the unit vector \cpp{struct vector v = \{1,1,1\}}\link{https://en.cppreference.com/w/c/language/struct_initialization}. To access the x component of the vector, we write \cpp{v.x} and to assign a new value the expression \cpp{v.x=42} is used. For more details we refer to~\cite[Chapter~4]{andrew2000accelerated}.

%----------------------------------------------------------------------------------------
\subsubsection{Constructor}
\index{constructor}
\index{structure!constructor}
%----------------------------------------------------------------------------------------
Each \cpp{struct} and \cpp{class} has a default constructor\link{https://en.cppreference.com/w/cpp/language/default_constructor}. However, one can overload the constructor for example to initialize the vector a zero $v=\{0,0,0\}$. Line~11 shows the constructor to initialize an zero vector. The constructor is like a function without the \cpp{return} option with the same name as the \cpp{struct} and \cpp{class}. As the constructor arguments the three vector components are given. Note that we assign the value zero to all of them. In Line~12 we assign the argument's values to the variables within the struct by using \cpp{x(x)} which means that we assign the \cpp{double x} of the \cpp{struct} the value of the \cpp{x} in the parentheses. Now we can initialize the \cpp{struct} in two different ways. First, using \cpp{struct vector v;} will result in $v=\{0,0,0\}$ since we assign zero to all the values. Second, using \cpp{struct vector v = vector(1,2,3);} will result in $v=\{1,2,3\}$. For more details we refer to~\cite[Chapter~4]{andrew2000accelerated}.

%----------------------------------------------------------------------------------------
\subsubsection{Member function}
\index{member function}
\index{structure! member function}
%----------------------------------------------------------------------------------------
A often used task is to compute the length of a vector $\sqrt{x^2+y^2+z^2}$, thus we want to add this function to the \cpp{struct vector} to call \cpp{norm()} to compute the norm, see Line~15. The syntax for member functions is the same as for functions. see Section~\ref{sec:functions}. The main difference is that the function definition is between the parentheses of the \cpp{struct} definition. For more details we refer to~\cite[Chapter~4]{andrew2000accelerated}.

\begin{lstlisting}[language=c++,caption={Example for a structure for a three dimensional vector.\label{code:struct}},float,floatplacement=tb]
#include <cmath>

struct vector 
{
// vector components
double x;
double y;
double z;

// constructor
vector(double x=0, double y=0, double z=0)
	x(x), y(y), z(z) {}

// member function to compute the vector's length
double norm(){
	return std::sqrt(x*x+y*y+z*z);
}
}
\end{lstlisting}

\begin{exercise}
Transform the \cpp{struct} in Listing~\ref{code:struct} to a \cpp{class}.
\end{exercise}

%----------------------------------------------------------------------------------------
\subsection{Header and Source files}
\index{header file}
%----------------------------------------------------------------------------------------
A header file\link{https://docs.microsoft.com/en-us/cpp/cpp/header-files-cpp?view=vs-2019} is a text file and a common naming convention is that header files end with \textit{.h} or \textit{.hpp}, \emph{e.g.}\ \textit{average.h}. To use the defined function in the header file, the file is included using the \cpp{#include}\link{https://en.cppreference.com/w/cpp/preprocessor/include} expression for example \cpp{#include<average.h>}. Note that the header files if the C++ standard library and the C++ STL do not end with  \textit{.h} or \textit{.hpp}. Before we look into the syntax of a header file, some remarks on good and bad practice are given.\\ 

\noindent Following things are considered as good practice:
\begin{itemize}
\item Each header file provides exactly one functionality 
\item Each header file includes all its dependencies
\end{itemize}
Following things should not be in header files and be considered as bad practice:\\
\begin{itemize}
\item built-in type definitions at namespace or global scope
\item non-inline function definitions
\item non-const variable definitions
\item aggregate definitions
\item unnamed namespaces
\item using directives
\end{itemize}

\begin{lstlisting}[language=c++,caption={Example for header file.\label{code:header}},float,floatplacement=tb]
#ifndef UTIL_H  //include guard
#define UTIL_H

#include <vector>
#include <algorithm>

// Utilities for the vector container
namespace util {

double average(std::vector<double> vec){
return std::accumulate(vec.begin(), vec.end(), 0.0f) 
     / vec.size();
}
}
#endif
\end{lstlisting}
\vspace{0.25cm}

Listing~\ref{code:header} shows an example for a header file for the median function. At the beginning and at the end of each header file, the so-called include guards avoid that functions or data structures have multiple definitions. In Line~1 we check if the definition \cpp{UTIL_H} is not defined by using the expression \cpp{ifndef}\link{https://en.cppreference.com/w/cpp/preprocessor/conditional} and is closed in Line~15. The compiler checks if the  definition \cpp{UTIL_H} was already seen and only if not, the source code is compiled. To let the compiler know that the code was compiled the expression \cpp{define}\link{https://en.cppreference.com/w/cpp/preprocessor/replace} in Line~2 is used. A short form is the \cpp{#pragma once}\link{https://en.cppreference.com/w/cpp/preprocessor/impl}. Next, all headers needed in this file are included.\\

In Line~8 the \cpp{namespace}\link{https://en.cppreference.com/w/cpp/language/namespace} expression is used to avoid naming conflicts and structure in large projects. Because the function \cpp{average} is within \cpp{namespace util} defnied, the usage of this function is \cpp{double res = util::average(vector);}. With the namespaces one can structure the projects as computation, util, and IO for example. So by using the namespace it is more defined which functionality is provided. It is possible to nest namespaces to have more structure.\\

A common folder structure for a project with header files in shown in Listing~\ref{code:folder:header}. In the folder \textit{includes} all header files (*.hpp) and the folder \textit{sources} all source files (*.cpp) are collected. Listing~\ref{code:main:header} shows the usage of the average function defined in the file \textit{util.h}. However, to compile the file \textit{main.cpp} file, the compiler needs to know where the \textit{util.h} is located. The compilation of the \textit{main.cpp} is the same as before, but the path to the header files needs to be specified as \bash{-I ../includes}, see Listing~\ref{code:compile:header}.

\begin{minipage}{\linewidth}

\begin{minipage}{0.45\linewidth}
\begin{lstlisting}[language=bash,caption={Folder structure for a project with header files.\label{code:folder:header}}]
sources/
    main.cpp
includes/
    util.h
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}{0.45\linewidth}
\begin{lstlisting}[language=c++,caption={Example for the main.cpp file using a header file.\label{code:main:header}}]
#include<util.h>

int main(void){

std::vector<double> vec = {1,2,3};

double res = util::average(vec);
}
\end{lstlisting}
\end{minipage}


\begin{minipage}{\linewidth}
\begin{lstlisting}[language=bash,caption={Compilation of the main.cpp file using a header file.\label{code:compile:header}}]
g++ -o main -I ../includes main.cpp
\end{lstlisting}
\end{minipage}

\end{minipage}


%----------------------------------------------------------------------------------------
\subsection{Classes}
%----------------------------------------------------------------------------------------
One important feature provided by the C++ language is the feature \cpp{class}\link{https://en.cppreference.com/w/cpp/language/classes}. Note the with C we had \cpp{struct} which are very similar to the \cpp{class}. However, one thing of the C++ language is the compatibility to the C language. Meaning that it is possible to compile C code using a C++ compiler. Therefore, the \cpp{struct} keyword is still available but not really needed since the keyword \cpp{class} is provided. \\

Listing~\ref{code:class:definition} shows the definition of a \cpp{class} for a three dimensional vector. In Line~1 a \cpp{class} with the name \cpp{vector3} is defined. All source code within the \cpp{\{ \};} is in the scope of the \cpp{class}. Three so-called privacy\link{https://en.cppreference.com/w/cpp/language/access} option are available for classes. The first option is shown in Line~3. The \cpp{private} option means that the \cpp{double} values are only accessible within the \cpp{class} itself. So these values are hidden and can not be changed without using any of the \cpp{public} methods below. The methods below Line~7 are declared as public. Which means the are accessible from outside the \cpp{class}. Let us make an example for the accessibility by creating \cpp{Vector3 vector;} an object. Since \cpp{double x} is declared as \cpp{private}, we can not call \cpp{vector.x;} since it is not accessible from outside the class. However, we can type \cpp{double len = vec.norm();} since this method is defined as \cpp{public}. The third option is the \cpp{friend}\link{https://en.cppreference.com/w/cpp/language/friend} option. The \cpp{friend} option allows a function or another class access to private members. \\

A common practice is to have header files and class files to provide the functionality of a \cpp{class} to other classes. Listing~\ref{code:header:definition} shows the header file extracted from the \cpp{class} definition in Listing~\ref{code:class:definition}. In the header file the attributes and the member functions of the \cpp{class} are defined. For example the function \cpp{double norm();} has no definition in this file and it is not define how the function is implemented. However, we know that the \cpp{class vector3} has this function. The implementation of the function is done in the corresponding source file, see Listing~\ref{code:class:definition2}. Note that we have to include the corresponding header file in Line~1. In addition, in a class file, we have to add the name of the \cpp{class} to all functions, see Line~3, we have to add \cpp{vector3::} to the constructor and the function in Line~8. For more details we refer to~\cite[Chapter~9]{andrew2000accelerated}.\\

For the compilation, we have to first compile the source file using \bash{g++ -c vector3.cpp} to compile the class file \bash{vector3.cpp}. Note since we compile a file without a \cpp{int main()} function the option \bash{-c} is needed. The last step is to compile the \bash{main.cpp} file using \bash{g++ main.cpp vector3.o -o main}. Note the file \bash{vector3.o} was generated with the previous command. For more details about making compilation easier, we refer to Section~\ref{sec:cmake}.


\begin{lstlisting}[language=c++,caption={Example for a class definition.\label{code:class:definition}},float,floatplacement=tb]
class vector3 {

private:

double x , y , z;

public:

vector3(double x = 0, double y=0, double z=0)
    : x(x) , y(y) ,z(z) {}
    
double norm(){ return std::sqrt(x*x+y*y+z*z);}
};
\end{lstlisting}


\begin{lstlisting}[language=c++,caption={Corresponding header file to the class definition in Listing~\ref{code:class:definition}.\label{code:header:definition}},float,floatplacement=tb]
class vector3 {

private:

double x , y , z;

public:
vector3(double x = 0, double y=0, double z=0);

double norm();
};

\end{lstlisting}

\begin{lstlisting}[language=c++,caption={Corresponding class file to the class definition in Listing~\ref{code:class:definition}.\label{code:class:definition2}},float,floatplacement=tb]
#include "vector3.h"

vector3::vector2(double x, double y, double z)
{
    x = x; x = y; z = z;
}

double vector3::norm(){return std::sqrt(x*x+y*y+z*z)}
\end{lstlisting}


%----------------------------------------------------------------------------------------
\section{Building with CMake}
\index{CMake}
\label{sec:cmake}
%----------------------------------------------------------------------------------------
CMake\link{https://cmake.org/} is a cross-platform free and open-source software tool for managing the build process of software using a compiler-independent method. It supports directory hierarchies and applications that depend on multiple libraries. It is used in conjunction with native build environments such as Make, Ninja, Apple's Xcode, and Microsoft Visual Studio. It has minimal dependencies, requiring only a C++ compiler on its own build system\link{https://en.wikipedia.org/wiki/CMake}. \\

In the previous two section, we learned how to compile using header files and classes using the GNU compiler. However, for large code bases, one do not want to compile all files by hand or write a script to do so. CMake is a neat tool to generate the build recipe for us. First, we start to look into how to compile a single source file (\bash{main.cpp}). Therefore, we generate a \bash{CMakeLists.txt} file in the same folder as the source file is located. The content of the \bash{CMakeLists.txt} is shown in Listing~\ref{code:cmake:main}. In Line~1 the minimum required CMake version is specified. This is important because some features are only available in this version or are deprecated in any older version. In Line~2 the project's name is defined. In Line~3 we define that we want to compile the file \bash{main.cpp} as an executable with the name out. This would be equivalent to \bash{g++ main.cpp -o hello}. Listing~\ref{code:cmake:compile} shows how to compile the \bash{main.cpp} file using CMake. In line~1 a new folder with the name \bash{build} is generated. The best practice is to have a build folder where the code is compiled. So we can easily delete the folder and have a clean build. In Line~2 we change to the build folder. In Line~3 we call \bash{cmake ..} to generate the \bash{Makefile}. Note that we have to use the two dots, because the \bash{CMakeLists.txt} is located one folder above. In Line~4 we call \bash{make} to compile the code and in Line~5 we execute the compiled program. \\

For a project with class and header files, a common folder structure is shown in Listing~\ref{code:cmake:complex}. A common practice is to have a folder \bash{include} for the header files, a folder \bash{src} for the source files, and the \bash{CMakeLists.txt}. Listing~\ref{code:cmake:complex} shows the corresponding \bash{CMakeLists.txt} file. In Line~4 the include directory is added to the project which means \bash{-I ../includes} is added as an argument to the compiler. In Line~6 the source files to compile are added manually by specifying their file names. This is feasible for small projects, however, for large amount of files it is too much work. Line~10 shows are more handy way to add all source code files in the folder \bash{src}.The last step is to add all the sources to the executable in Line~12. Note that we only covered the minimal basics of CMake. For more details, we refer to~\cite{cmake}.        


\begin{minipage}{\linewidth}
\begin{minipage}{0.45\linewidth}
\begin{lstlisting}[language=bash,caption={Content of the CMakeLists.txt.\label{code:cmake:main}},emph={project, add_executable,cmake_minimum_required},emphstyle={\color{azure}\bfseries}]
cmake_minimum_required(VERSION 3.10.1)
project(hello_world)
add_executable(hello main.cpp)
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}{0.45\linewidth}
\begin{lstlisting}[language=bash,caption={Build instructions for CMake.\label{code:cmake:compile}}]
mkdir build 
cd build
cmake ..
make
./hello
\end{lstlisting}
\end{minipage}
\end{minipage}

\begin{minipage}{\linewidth}
\begin{minipage}{0.45\linewidth}
\begin{lstlisting}[language=bash,caption={Structure of a CMake project.\label{code:cmake:folder}},emph={project, add_executable,cmake_minimum_required},emphstyle={\color{azure}\bfseries\underbar}]
 .
 |-- CMakeLists.txt
 |-- build
 |-- include
 |   \-- vector2.h
 \-- src
     |-- vector2.cpp
     \-- main.cpp
 3 directories, 4 files
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}{0.45\linewidth}
\begin{lstlisting}[language=bash,caption={Build instructions for CMake.\label{code:cmake:complex}},emph={project, add_executable,cmake_minimum_required,include_directories,file},emphstyle={\color{azure}\bfseries\underbar}]
project(directory_test)
 
#Include headers
include_directories(include)
 
#Adding all sources 
#set(SOURCES src/main.cpp src/vector2.cpp)
 
#Adding sources easier
file(GLOB SOURCES "src/*.cpp")
 
add_executable(test ${SOURCES})
\end{lstlisting}
\end{minipage}
\end{minipage}


%----------------------------------------------------------------------------------------
\section{Generic programming}
\label{sec:generic:programming}
%----------------------------------------------------------------------------------------
In some cases, we need to write the same function for different data types, \emph{e.g.}\ \cpp{double} and \cpp{float}, see Listing~\ref{code:generix:example}. We would need to write the same function for all data types. Thus, we will produce the same computation multiple time and have too much redundant code.If there is an error in the computation, we would have to correct it for all of the functions. Function templates\link{https://en.cppreference.com/w/cpp/language/function_template}\index{function~template} are provided by the C++ language. Listing~\ref{code:generix:example} shows starting at Line~11 how to combine the previous two function into one. In Line~11 the expression \cpp{typename} indicates that we define a function template and within the parentheses the \cpp{typename T} is defined which is a placeholder for the explicit data type. For the remaining function definition everything keeps the same and only the specific data type, \emph{e.g.}\ \cpp{double} and \cpp{float}, is replaced by \cpp{T}. Now, the function is used as \cpp{add<double>} or \cpp{add<float>} or \cpp{add<int>} for the various data types without explicit implementing all of them. This is a neat feature to reduce the amount of code.\\

\begin{lstlisting}[language=c++,caption={Example for the usage function templates.
\label{code:generix:example}},float,floatplacement=tb]
// Definition of multiple functions
double add(double a, double b) {
	return a + b;
}

float add(float a, float b) {
	return a + b;
}

// Function template
template<typename T>
T add(T a, Tb){
	return a+b;
}
\end{lstlisting}

The same is possible for \cpp{struct} and \cpp{classes} by adding \cpp{template<typename T>}\link{https://en.cppreference.com/w/cpp/language/templates} above the definition and using the \cpp{T} instead of \cpp{double} as in Listing~\ref{code:struct}.  Now, the function is used as \cpp{struct vector <double> v;} or \cpp{struct vector<float> v;} or \cpp{struct vector<int> v;} for the various data types without explicit implementing all of them. For the function \cpp{norm()} there is no need to use \cpp{template<typename T>} again and the return type \cpp{double} is replaced by \cpp{T}. Fore more details, we refer to~\cite{josuttis2003c++}. For further watching, we recommend the C++ Lecture 2 - Template Programming 2\link{https://www.youtube.com/watch?v=iU3wsiJ5mts} and C++ Lecture 4 - Template Meta Programming\link{https://www.youtube.com/watch?v=6PWUByLZO0g}.

\begin{exercise}
Use the \cpp{struct} in Listing~\ref{code:struct} and make it a generic one by adding the \cpp{template<typename T>} and replace all \cpp{double} by \cpp{T}.
\end{exercise}

%----------------------------------------------------------------------------------------
\section{Lambda function}
\index{function!lambda}
\index{lambda function}
\label{sec:lambda:function}
%----------------------------------------------------------------------------------------
In Section~\ref{sec:functions} function expression was introduced as \cpp{int compute(int a, int b);}. Here, the function has a name \cpp{compute} and this name is used to call the function. However, in some cases it can be neat to use a function exactly once, for example in the STL Algorithms, see Section~\ref{sec:stl:algorithms}. To use a function only one time the so-called lambda expression or lambda function\link{https://en.cppreference.com/w/cpp/language/lambda} is shown in Listing~\ref{code:lamda:definition}. Within the $[\ldots ]$ the capture clause of the parameters within the $(\ldots )$ are defined. Ans as for the function the code of the function is defined within $\{\dots \}$. Note that the \cpp{-> return-type}, \emph{e.g.}\ \cpp{-> int}, is somehow an optimal parameter and in most cases this parameter is evaluated by the compiler and only in few special cases the return type needs to be defined. Following capture clauses\link{https://en.cppreference.com/w/cpp/language/lambda\#Lambda_capture} are available:
\begin{itemize}
\item  \lstinline|[&]| : capture all external variable by reference
\item  \lstinline|[=]| : capture all external variable by value
\item  \lstinline|[a, &b]| : capture a by value and b by reference
\end{itemize}
For more details about the capture classes, we refer to the next section.\\

Listing~\ref{code:lamda:example} sketches some practical example how to transform a function to a lambda expression. From Line~2--4 defines the function to print the element of the vector piece-wise to the standard output stream. In Line~5 the short form of a \cpp{for} loop is used to loop over all elements of the vector piece-wise. Note that \cpp{i} is not the index and it is the value of the vector at position \cpp{std::for_each} is handling. Since we use the function \cpp{void print(int i)} only once, a short form of this function is used in Line~8. 

\begin{exercise}
Try to understand the transformation of the function \cpp{void print(int i)} to the corresponding lambda function.
\end{exercise}

Listing~\ref{code:lamda:example} also shows some example to find the first number greater than $4$ in a vector using the \cpp{std::find_if}\link{https://en.cppreference.com/w/cpp/algorithm/find}. Many more algorithms are available in the \cpp{#include <algorithm>}\link{https://en.cppreference.com/w/cpp/algorithm}.

\begin{lstlisting}[language=c++,caption={Example for lambda functions.
\label{code:lamda:definition}},float,floatplacement=tb]
[ capture clause ] (parameters) -> return-type  
{   
   //definition of method   
} 
\end{lstlisting}


\begin{lstlisting}[language=c++,caption={Practical example for a lambda function.
\label{code:lamda:example}},float,floatplacement=tb]
// Print the values of the vector using a function
void print(int i){
std::cout << i << std::endl;
}
std::for_each(v.begin(), v.end(), print); 

// Print the values of the vector using a function
std::for_each(v.begin(),v.end(),
	[](int i){std::cout<< i << std::endl;})
	
// Find the first number greater than 4 in a vector
std::vector<int>:: iterator p = std::find_if(
    v.begin(), 
    	v.end(), 
    	[](int i) 
    { 
        return i > 4; 
    }); 
std::cout << "First number greater than 4 is : " << *p << endl;
\end{lstlisting}

%----------------------------------------------------------------------------------------
\section{Pointers}
\index{pointer}\index{pointer!raw}
%----------------------------------------------------------------------------------------
Imagine following conversation:
\begin{flushleft}
\textbf{Person A:} Would you teach a toddler how to eat with a butcher's knife?
\end{flushleft}
\begin{flushright}
\textbf{Person B:} No!
\end{flushright}
\begin{flushleft}
\textbf{Person A:} So stop mentioning pointers to people barely
starting with C++.
\end{flushleft}
Therefore, the book does not talk much about pointers, because in most cases, you do not need pointers to implement mathematical algorithms. If you need them, you should carefully check your implementation and see if you can avoid them. However, the introduce the basics so you know about pointers and can use them if you really need them.\\

A pointer $p$ is a value that represents the address of an object. Every object $x$ has a distinct unique address to a part of the computer's memory. Listing~\ref{code:pointer:introduction} gives some example. In Line 2 the object \cpp{int x} is generated in the computer's memory and the value \cpp{42} is stored. In Line~5 the address to the memory where the object \cpp{x} is stored is store in \cpp{int* p} by using the so--called \cpp{&} address operator\index{operator!address}\index{address operator}. In Line~8 we get the vlaue \cpp{42} stored at the address \cpp{p} by using the so-called deference operator\index{operator!dereference}\index{dereference operator}. In Line~11 the value \cpp{42} of the object \cpp{x} is printed. In Line~12 we use the pointer \cpp{p} to the object \cpp{x} to set a new value \cpp{43}. In Line~13, we print the object \cpp{x} again and we will see the new vlaue \cpp{43} without accessing the object \cpp{x} directly.\\

\begin{lstlisting}[language=c++,caption={Introduction to pointers to objects.
\label{code:pointer:introduction}},float,floatplacement=tb]
// Initialize
int x = 42;

// Get the pointer to the object x
int* p = &x;

// Get the object the pointer is pointing to
int tmp = *p;

// Using pointers to manipulate objects
std::cout << x << std::endl;
*p = 43;
std::cout << x << std::endl;

\end{lstlisting}

In the first example, we used a pointer to a single object. In the second example, we will use a pointer to an array of objects, see Listing~\ref{code:pointer:array}. In Line~1 a pointer to the \cpp{array} is obtained. Using the dereference operator on the pointer gives us access to the first element of the array, see Line~2. With the so-called pointer arithmetic\index{pointer arithmetic} we can access the second and third element of the error by adding one or two the pointer before we use the dereference operator. In Line~13 we compute the distance between two pointers which is the length of the array in this case. Note that \lstinline|ptrdiff_t|\link{https://en.cppreference.com/w/cpp/types/ptrdiff_t} is a signed type because the distance can be negative.\\


\begin{lstlisting}[language=c++,caption={Introduction to pointers to range of objects.
\label{code:pointer:array}},float,floatplacement=tb]
int* array = new int[3];
*array = 1;
*(array + 1) = 2;
*(array + 2) = 3;

// Accessing the first element
int first = *array;

// Accessing the second element
int second = *(array + 1);

// Getting the distance between two pointers
ptrdiff_t dist = array+2 - array;
\end{lstlisting}

In the last example, we look into pointers to function, the so-called function pointers. In Listing~\ref{code:pointer:function} shows how to generate function pointers to the function \cpp{square}. In Line~7 the first possibility to generate a function pointer to the \cpp{square} function. The first \cpp{int} stands for the return type of the function and the second \cpp{int} for the function's argument. In Line~2 the left-hand side is the same, but on the right-hand side we use the address operator. In Lines~112--12 the function is called using its function pointer. Note that each of two lines to get the pointer or call the function are equivalent. 


\begin{lstlisting}[language=c++,caption={Example for function pointers.
\label{code:pointer:function}},float,floatplacement=tb]
int square(int a)
{
return a * a;
}

// Generating a function pointer
int (*fp)(int) = square; //We need the (int) for
int (*fp2)(int) = &square; // the return type

// Calling the function using its pointer
std::cout << (*fp)(5);
std::cout << fp2(5);

\end{lstlisting}

%----------------------------------------------------------------------------------------
\subsection{Memory management}
\label{sec:memory:management}
%----------------------------------------------------------------------------------------
From the Spider-Man comics and the movies, we all know the sentence
\begin{center}
With great power there must also come great responsibility
\end{center}
and this can be referenced for the usage of pointers as well. In C++ we have two kind of memory management:
\vspace{0.25cm}
\begin{enumerate}
\item \textbf{Automatic memory management}\\
This is what happens using the C++ standard library and the C++ STL. The system is allocation the memory for use, e.g. if we generate some array \cpp{double int[8]} or one of the containers. If the array goes out of scope which means it is not used anymore, the system deallocates the used memory.
\item \textbf{Dynamic memory management}\\
If we use a pointer, the user has to allocate and clear the memory for each generated object. The programmer allocates the memory with the \lstinline|new|\link{https://en.cppreference.com/w/cpp/language/new} keyword
and deallocates the memory with the the \lstinline|delete|\link{https://en.cppreference.com/w/cpp/language/delete} keyword.
\end{enumerate}
\vspace{0.25cm}
Listing~\ref{code:memory:management} shows some examples for dynamic memory management. In Line~2 the memory for one single integer value is allocated. In Line~5 the memory is deallocated which means the memory at this address is free again. In Line~8 the memory for five integer values is allocated. Note that here we have to add \cpp{[]} to the \cpp{delete} keyword.

\begin{lstlisting}[language=c++,caption={Example for dynamic memory management.
\label{code:memory:management}},float,floatplacement=tb]
// Allocate the memory for one single integer value
int* p = new int(42);

// Deallocate the memory
delete p;

// Allocate the memory for five integer values
int* p = new int[5];

// Deallocate the memory
delete[] p;
\end{lstlisting}


%----------------------------------------------------------------------------------------
\section{Moving data}
\label{sec:moving:data}
%----------------------------------------------------------------------------------------
In some cases, if we pass a value to some function, we like to avoid to copy the data and instead we like to \cpp{std::move}\link{https://en.cppreference.com/w/cpp/utility/move} the data. Let us look into the example in Listing~\ref{code:move} to explain what we mean by moving a value. In Line~4 we add the string \cpp{hello} to the vector using the \cpp{push_back} method. However, by passing the string \cpp{hello} a copy of the string is passed to the function. Depending on the object size, the copying takes some time. However, if we print the content of the string \cpp{hello} by using the copy, the value of the string will be \cpp{"Hello"}. If, we want to avoid the copying, one can use the \cpp{std::move} function in Line~9. However, if we print the content of the sting \cpp{hello}, the empty string will be printed. This happens since we moved the data (in that case the content \cpp{"Hello"}) to the \cpp{std::vector<std::string>}. So, if we print the content of \cpp{v[i]}, we will see again the content \cpp{"Hello"} again, since we moved the content. Note that you have to be aware of undefined states after moving. For example \cpp{v.clear()} is a valid state since there is no precondition. However, \cpp{v.back()} could result in a undefined behavior, since the size of the string is zero.


\begin{lstlisting}[language=c++,caption={Example for the usage of \cpp{std::move} to move data.
\label{code:move}},float,floatplacement=tb]
std::string hello = "Hello";
std::vector<std::string>v;

// Add the string hello to the end of the vector
v.push_back(hello);
std::cout << "After copying the string, its content is: " << hello << std::endl;

//Move the data and avoid the copying
v.push_back(std::move(hello));
std::cout << "After moving the string, its content is: " << hello << std::endl;

//Printing the moved content
std::cout << "After moving the string, its content is: " << v[1] << std::endl;

\end{lstlisting}

%----------------------------------------------------------------------------------------
\subsection{Smart pointer}
\label{cpp:smart:pointer}
%----------------------------------------------------------------------------------------
The so-called smart pointers\index{pointer!smart} are defined in the header \cpp{#include <memory>}\link{https://en.cppreference.com/w/cpp/header/memory}. In the previous section, we looked at so-called raw pointers and these should be used only in small code blocks of limited scope or where performance is a major issue. Using a raw pointer you are responsible to manage the memory and deallocate the memory if the object is not needed anymore. Using a smart pointer there is no need to call the \cpp{delete} explicitly. The first smart pointer is the \cpp{std::unique_ptr}\link{https://en.cppreference.com/w/cpp/memory/unique_ptr}\index{pointer!unique}, see Listing~\ref{code:pointer:unique}. The unique pointer points to exactly one object in the memory and no other pointer can point to this object. In Line~1 we initialize a smart unique pointer containing a array \cpp{double []} by using \cpp{std::unique_ptr<double[]>a}. We use the \cpp{new} operator to allocate a array of size two. For more details about the \cpp{new} keyword, we refer to Section~\ref{sec:memory:management}. In the Lines~5--6 the values of the array are initialized. Note that the Line+9 is commented out on purpose, since this line of code will not compile. Since we use a \cpp{std::unique_ptr} for the array \cpp{a}, we can not use a second smart pointer \cpp{b} pointing to \cpp{a}. However, moving the pointer \cpp{a} to the unique pointer \cpp{b} will work, since we move the control from \cpp{a} to \cpp{b}. Fore more details about \cpp{std:move}, we refer to Section~\ref{sec:moving:data}.\\

\begin{lstlisting}[language=c++,caption={Using the smart unique pointer.
\label{code:pointer:unique}},float,floatplacement=tb]
// Generate a unique pointer of a double array
std::unique_ptr<double[]>a(new double[2]);

// Initialize the values
a[0] = 1;
a[1] = 2;

// Generate a copy of the array a
//std::unique_ptr<double[]>b(a);

// Generate a copy of the array a
std::unique_ptr<double[]>b(std::move(a));
\end{lstlisting}


The second smart pointer is the so--called share pointer \cpp{std::shared_ptr}\link{https://en.cppreference.com/w/cpp/memory/shared_ptr}\index{pointer!shared}. The shared pointer allows that pointers can point to the same object and a reference counter is used. Listing~\ref{code:pointer:smart} shows the usage of smart pointers. In Line~2 a smart pointer of a double array is generated and we allocate a array of size two. Now, since we use a shared pointer the pointer \cpp{a} can be passed to the new share pointer \cpp{b}, since multiple pointer can point to the same object. In addition, we can use the function \cpp{use_count()} to check the pointers pointing to the object the pointer \cpp{a} is pointing to. 


\begin{lstlisting}[language=c++,caption={Using the smart unique pointer.
\label{code:pointer:smart}},float,floatplacement=tb]
// Generate a unique pointer of a double array
std::shared_ptr<double[]>a(new double[2]);

// Initialize the values
a[0] = 1;
a[1] = 2;

// Generate a copy of the array a
//std::unique_ptr<double[]>b(a);

std::cout << a.use_count) << std::endl;
\end{lstlisting}


\newpage
\theendnotes

%----------------------------------------------------------------------------------------
\chapter{The C standard library}
\label{chapter:cpp:lib}
%----------------------------------------------------------------------------------------
The ANSI C standard\link{http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf}\index{ANSI C} is the specification for the C standard library (libc). The C standard library provides following functionality
\begin{itemize}
\item Handling set of characters in the \cpp{#include <cstring>} header,
\item handling times and dates in the \cpp{#include <ctime>} header,
\item Support of complex numbers in the \cpp{#include <ccomplex>},
\item Mathematical functions in the \cpp{#include <cmath>} header,
\item Limits of integer types in the \cpp{#include <climits>} header,
\end{itemize}
and many more features. However, these are the features we will use most in this course. For more details, we refer to~\cite{josuttis2012c++}.

%----------------------------------------------------------------------------------------
\section{Strings}
\index{libc!string}
\index{string}
%----------------------------------------------------------------------------------------
The STL provides the class \lstinline[language=C++]{string}\endnote{\url{http://www.cplusplus.com/reference/string/string/}} to store sequences of characters. For the usage of this class the header \lstinline[language=c++]{#include <string>} has to be added to the cpp file to make \lstinline[language=c++]{std::string} available. Listing~\ref{code:strings} shows how to use the string class to write a set of characters to standard output stream\endnote{\url{http://www.cplusplus.com/reference/iostream/cout/?kw=cout}} \lstinline[language=c++]{std::cout} and read them from standard input stream\endnote{\url{http://www.cplusplus.com/reference/iostream/cin/?kw=cin}} \lstinline[language=c++]{std::cin}. To use these functionality the \lstinline[language=c++]{#include <iostream>} header is needed. \index{iostream!cin}\index{iostream!cout} \\

In Line~7 the set of characters \lstinline[language=c++]{"Please enter your name: "} is written to the standard output stream using the operator \lstinline[language=c++]{<<}. In Line~9 a string object with the identifier \lstinline[language=c++]{name} is declared. All variables have a name \lstinline[language=c++]{name} and a type  \lstinline[language=c++]{std::string}. Since the variable is declared but not initialized yet, the variable is empty or a null string. The assignment operator \lstinline[language=c++]{=} is used to initialize the variable with a set of characters  \lstinline[language=c++]{std::string name = "Mike"}. In Line~10 the variable is initialized with the content provided by the standard input stream \lstinline[language=c++]{std::cin} and the \lstinline[language=c++]{>>} operator. In Line~12 the content of the variable is written to the standard output stream. Note that you can concatenate strings using the \lstinline[language=c++]{>>} operator multiple times. To generate a line break the statement \lstinline[language=c++]{std::endl} is used. Note that we only handled the basis features here, since these are necessary for the purpose of this course. For more details we refer to~\cite[Chapter~1]{andrew2000accelerated}.


\lstinputlisting[language=C++,caption={Example reading and writing strings.\label{code:strings}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture1-string-io.cpp}


%----------------------------------------------------------------------------------------
\section{Random number generation}
\index{libc!random number generation}
\index{random number generation}
\label{sec:random:numbers}
%----------------------------------------------------------------------------------------
For some applications, \emph{e.g.}\ Monte Carlo methods, see Chapter~\ref{sec:monte:carlo}, random numbers are essential. The trivial way to generate a integer random number in the range of zero and \cpp{RAND_MAX} is to use \cpp{std::rand}\link{http://www.cplusplus.com/reference/cstdlib/rand/} provided by the \cpp{#include <cstdlib>} header. Listing~\ref{code:srand} shows a small example to generate a random number. Note that one has to provide a seed to the random number generator to get a different random numbers each time the program is executed. One way to do so, is to use the current time \cpp{std::time(0)}\link{http://www.cplusplus.com/reference/ctime/time/?kw=time} provided by the \cpp{#include <ctime>} header. Line~10 shows how to use the current time passed as an argument \cpp{std::srand(std::time(0))} as a seed for the random number generator. Line~\mbox{12} shows how to get one random number. Note that the seed has to be set only once, but always before any random number is drawn.\\

\lstinputlisting[language=C++,caption={Example using the trivial random number generator.\label{code:srand}},float,floatplacement=tbp]{ParallelComputationMathExamples/chapter2/lecture2-random.cpp}

For more advanced usage of random number generators the \cpp{#include<random>} header is provided. More advanced means that not only integer random number can be drawn and range can be provided. Listing~\ref{code:distrand} shows how to generate uniform distributed random numbers. Line~8 generates a random number device \cpp{std::random_device rd}\link{http://www.cplusplus.com/reference/random/random_device/}. Next, the engine for the random number generation is chosen. In this case the \cpp{mersenne_twister_engine}~\cite{matsumoto1998mersenne} is used by providing the random device as an argument \cpp{std::mt19937 gen(rd())}\link{http://www.cplusplus.com/reference/random/mersenne_twister_engine/}. Next the uniform distribution has to be specified by \cpp{std::uniform_int_distribution} for integer values and \cpp{std::uniform_real_distribution} for floating point numbers. In Line~12 the interval from 1 to 6 for integer numbers and in Line~14 for double numbers is specified. Line~15 shows how to get a random number by using the distribution by passing the engine as an argument \cpp{dis(gen)}.

\lstinputlisting[language=C++,caption={Example using the trivial random number generator.\label{code:distrand}},float,floatplacement=tbp]{ParallelComputationMathExamples/chapter2/lecture2-distrandom.cpp}

%----------------------------------------------------------------------------------------
\section{Numerical limits}
\index{numerical limits}
%----------------------------------------------------------------------------------------
Since the limits of the numerical data types depend on the various things, the \cpp{#include <limits>} header\link{https://en.cppreference.com/w/cpp/types/numeric_limits} is available to access this information. For the integer data types, the function \cpp{std::numeric_limits<unsigned int>::min()} is provided to receive the smallest finite value and the function \cpp{std::numeric_limits<unsigned int>::max()} the largest finite value of the \cpp{unsigned int} data type.\\

For floating point numbers, two additional values are accessible, see Listing~\ref{code:numerical:limits}. In Line~8 the rounding error \cpp{std::numeric_limits<double>::round_error()}\link{https://en.cppreference.com/w/cpp/types/numeric_limits/round_error} which returns the maximum rounding error of
the given floating-point type is shown. In Line~9 the value epsilon \cpp{std::numeric_limits<double>::epsilon()}\link{https://en.cppreference.com/w/cpp/types/numeric_limits/epsilon} which is the difference between 1.0 and the next representable value of the given floating-point type is obtained. Fore more details about the IEEE 474 standard how floating point numbers are represented in the computer we refer to~\cite{4610935,goldberg1991every}. The next two lines of code show how to access the minimal and maximal value.


\lstinputlisting[language=C++,caption={Example accessing the numerical limits of floating point types.\label{code:numerical:limits}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture3-limits2.cpp}


%----------------------------------------------------------------------------------------
\section{Reading and writing files}
%----------------------------------------------------------------------------------------
For numerical simulations, it is essential to read files, \emph{e.g.}\ configuration files, and store their values or write the simulation results to permanent storage. First, we look into how to read the content of a file line by line. To do so, the \cpp{ifstream}\link{https://en.cppreference.com/w/cpp/io/basic_ifstream} provided by the \cpp{#include <fstream>}\link{https://en.cppreference.com/w/cpp/header/fstream} header. Listing~\ref{code:io:reading} shows how to read the file's content \cpp{"example.txt"} line by line. In Line~7 a \cpp{ifstream} with the name \cpp{myfile} is declared. With the parentheses its constructor is called and the parameter is the file name of the file we want to open. Note that we assume that the file is located next to the cpp file. In Line~8 we check if the file could be opened successful. In that case the function \cpp{is_open()}\link{https://en.cppreference.com/w/cpp/io/basic_fstream/is_open} will return \cpp{true}. In line~10 the function \cpp{getline}\link{https://en.cppreference.com/w/cpp/string/basic_string/getline} is called to access the each line of the file. The first argument is the \cpp{ifstream} and the second argument is a \cpp{std::string} where the line of the file is stored. Each time the function is called there is new content in the argument \cpp{line}. If there is no next line. the function returns \cpp{false} and the \cpp{while} loop stops. In Line~16 the \cpp{ifstream} is closed by calling the \cpp{close()}\link{https://en.cppreference.com/w/cpp/io/basic_ifstream/close} function.\\

\lstinputlisting[language=C++,caption={Example for reading the content of file "example.txt" line by line.\label{code:io:reading}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture3-reading.cpp}

\begin{exercise}
Instead of printing the file content to the standard output device, store each line of the file in a \cpp{std::vector<string>}.
\end{exercise}
\vspace{0.25cm}

Second, we look into how to write the text \cpp{"Writing this to a file"} into the file \cpp{"example.txt"}, see Listing~\ref{code:io:writing}. In Line~6 the \cpp{std::ofstream}\link{https://en.cppreference.com/w/cpp/io/basic_ostream} is declared. In Line~7 the function \cpp{open()}\link{https://en.cppreference.com/w/cpp/io/basic_ofstream/open} is called. The first argument is the file name of the file to create. The second argument is the file mode \cpp{std::ios::out}\link{https://en.cppreference.com/w/cpp/io/ios_base/openmode}. In Line~8 the operator \cpp{<<} is used to write the string to the file. By using \cpp{"\n"} we indicate a line break and all content after will be in a new line of the file. In Line~9 the file is closed by calling the \cpp{close()}\link{https://en.cppreference.com/w/cpp/io/basic_ofstream/close} method.

\begin{exercise}
Instead writing one string to the file, write all string in a \cpp{std::vector<string>} to the file with each string in a new line.
\end{exercise}

\lstinputlisting[language=C++,caption={Example for writing to the file "example.txt".\label{code:io:writing}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture3-writing.cpp}. 


\newpage
\theendnotes

%----------------------------------------------------------------------------------------
\chapter{The C++ Standard Template Library (STL)}
\label{chapter:stl}
%----------------------------------------------------------------------------------------

%----------------------------------------------------------------------------------------
\section{Overview of the STL}
\index{STL}
%----------------------------------------------------------------------------------------
Figure~\ref{fig:stl:components} shows the four components of the C++ Standard Template Library (STL). The main focus in this course is on the algorithm component, container component, and iterators component. The functions component provides the so--called \texttt{Functors}\link{https://www.geeksforgeeks.org/functors-in-cpp/}. A functor is an object, which is treated a function or a function pointer. The component iterators\link{https://en.cppreference.com/w/cpp/iterator} provides six iterators for working upon a sequence of values, \emph{e.g.}\ containers. The usage of iterators will be discussed in Section~\ref{ref:stl:iterators}. For the Algorithms component\link{https://en.cppreference.com/w/cpp/algorithm} following algorithm classes:
\begin{itemize}
\item Sorting\link{https://en.cppreference.com/w/cpp/algorithm/sort} - Ordering elements in a container with respect to their order,
\item Searching\link{https://en.cppreference.com/w/cpp/algorithm/search} - Searching for elements in a sorted array, and
\item STL algorithms - Provides algorithms, like finding the largest element (max\link{https://en.cppreference.com/w/cpp/algorithm/max}) in an container or compute the sum\link{https://en.cppreference.com/w/cpp/algorithm/accumulate} of all elements;
\end{itemize}
will be reviewed. All of these algorithm classes will be showcased on the container \cpp{std::vector} in Section~\ref{sec:containers}. For more details on the STL we refer to~\cite{o2017mastering,stepanov1995standard}, but remember learning C++ is like learning a new sportive activity, practicing (writing code) is essential to improve your skills. For further watching, we recommend the C++ Lecture 1 - The Standard Template Library\link{https://www.youtube.com/watch?v=asGZTCR53KY&list=PL7vEgTL3FalY2eBxud1wsfz8OKvE9sd_z}.\\ 

\textcolor{azure}{Most important take away of this section is: 
\begin{itemize}
\item Never implement your own algorithm or container, if you can find it within the STL.
\item If you can not find it within the STL, think if you really need this feature.
\end{itemize}
}

\begin{figure}[tb]
    \centering
    \begin{tikzpicture}
      [mindmap,
      grow cyclic,
      every node/.style=concept,
      concept color=cadetgrey!40,
      level 1/.append style={sibling angle=360/4},
      level 2/.append style={sibling angle=37.5},
      ]
    \node [root concept] {STL}
        child{
          node    {Algorithms} 
          child { node {Sorting} }         
          child { node {Searching} }      
          child { node {STL algorithms} }
          child { node {Array algoritms} }
          child { node {Partion operaitons } }         
        }
        child{
          node    {Containers}
          child { node {Sequence containers}
			child{ node{\cpp{std::vector}} }
			child{ node{\cpp{std::list}} } 
			child{ node{\cpp{std::array}} }                     
           }
          child { node {Container adaptors } }
          child { node {Associative containers } }
          child { node {Unordered associative containers } }
        }
        child{
          node    {Functions}
        }
        child{
          node    {Iterators}
        }
        ;
    \end{tikzpicture}
    \caption{Overview of the C++ Standard Template Library (STL): Algorithms, Containers, Iterators, and Functions. This course will mainly focus on the Algorithms and Container components.}
    \label{fig:stl:components}
\end{figure}

%----------------------------------------------------------------------------------------
\section{Containers}
\index{STL!containers}
\index{containers}
\label{sec:containers}
%----------------------------------------------------------------------------------------
Before we look into the containers, we start with an example to showcase the need of containers. Let us assume we want to compute the average
\begin{align}
a = \frac{1}{n}\sum\limits_{i=1}^n i
\end{align}
of the number from one to $n$. Listing~\ref{code:average} sketches how to compute the average using the ingredients of the previous chapter. Only one new feature \cpp{std::setprecision}\link{https://en.cppreference.com/w/cpp/io/manip/setprecision} is a new feature provided by \cpp{#include <iomanip>} header and you should be able to understand this code. If you have any issues, we highly recommend to go back to the previous chapter and read one more time the section about loop statements, see Section~\ref{sec:iteration:statements}. With \cpp{std::setprecision(3)} it is specified that only three digits of the following floating point number are printed. For example if one wants to print \cpp{const long double pi = std::acos(-1.L);} and uses \cpp{std::setprecision(3)} only $3.14$ is printed. Thus, depending on the application the accuracy can be varied.\\

In this example multiple values are read from the standard input using \cpp{while (std::cin >> x)} in Line~9. The \cpp{while} statement reads a new value from the standard input device, stores it in the variable \cpp{x}, until the users types \cpp{\\n}, which corresponds to a line break, since the loop condition is \cpp{false}. However, if we want to compute the median of a list of elements, we need to store the elements, process them, and print the average. To store these elements, we will look into the \cpp{std::vector} container and the \cpp{#include<algorithm>} header. In Section~\ref{sec:stl:algorithms} an example to compute the average is provided, since we have all the needed ingredients studied. For more details we refer to~\cite[Chapter~3]{andrew2000accelerated}.  

\lstinputlisting[language=C++,caption={Computation of the average of the numbers from one to $n$.\label{code:average}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture2-average.cpp}

%----------------------------------------------------------------------------------------
\subsection{Vector}
\index{STL!vector}
\index{vector}
%----------------------------------------------------------------------------------------
The container \cpp{std::vector} represents an object to store an arbitrary amount of the same data types. From the mathematical point of view the \cpp{std::vector} is comparable to a vector
\begin{align}
\mathbf{v} = \{v_i \,\vert\, i=1,\ldots,n \} \text{ with } \mathbf{v}[i] = v_i \text{ and }  \vert v\vert = n\text{.} 
\end{align}
Note in C++ the elements in a vector start with index zero and the index of the last element is $n-1$ with a vector length of $n$. To initialize an empty vector with the name \cpp{values} the expression \cpp{std::vector<double> values;} is used. Between the parenthesis the data type of all elements of the vector is specified. In this case only \cpp{double} values can be stored in the vector. In this case the length of the vector \cpp{values.size()} will return zero and \cpp{values.empty()} will return \cpp{true} since the vector is empty with the meaning that there are not elements stored. In addition, a vector can be filled with values during its definition using \cpp{std::vector<double> v = {1, 2.5};}. In this case the length of the vector \cpp{values.size()} will return two and \cpp{values.empty()} will return \cpp{false}.\\

Let us write the computation of the average again using the \cpp{std::vector}. Listing~\ref{code:averagecontainers} shows the new implantation of the computation of the average (Listing~\ref{code:average}). In Line~7 the \cpp{std::vector} with the name \cpp{values} for storing \cpp{double} values is declared. In Line~11 with \cpp{values.push_back{x}} the value of \cpp{x} is inserted at the end of the vector. To replace the third element of the vector by the value $1.5$ the expression \cpp{values[3]=1.4} is used. To replace the last element with zero the expression \cpp{values[values.size()-1]=0} is used. To access the elements on the $i$-th index the expression \cpp{values[i]} is used. The first element is accessed using \cpp{values.first()} and the last element using \cpp{values.last()}. More details about iterators are discussed in Section~\ref{ref:stl:iterators}. The last element is deleted by using \cpp{values.pop_back()} and the $i$-th element by \cpp{values.erase(values.start()+i}.\\


In Line~14 the sum of all elements in the vector is computed by using \cpp{std::accumulate} from the Algorithms component. The first argument \cpp{values.begin()} and the second argument \cpp{values.end()} defines the range of the vector. Here, it is the full vector, but for example to keep out the first element of sum, one can use \cpp{values.begin()+1}. The third argument is the initial value of the sum. More details about the Algorithms will be studied in Section~\ref{sec:stl:algorithms}. \\

Compared to other containers, \emph{e.g.}\ \cpp{std::list}, the \cpp{std::vector} is designed for
\begin{enumerate}
\item Are sufficient for small amount of elements. A good estimate is around 7000 elements,
\item Are optimized to access elements arbitrary, and
\item Performs well adding one element by the time to the end of the vector.
\end{enumerate}
For example the complexity for inserting or removing an element in a vector is $\mathcal{O}(n^2)$ and for the container \cpp{std::list} the complexity is $\mathcal{O}(n)$~\cite{michalewicz2013genetic,knuth1997art}.

\lstinputlisting[language=C++,caption={Computation of the average of the numbers from one to $n$ using containers.\label{code:averagecontainers}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture2-averagecontainers.cpp}


%----------------------------------------------------------------------------------------
\subsection{List}
\index{list}
\index{STL!list}
%----------------------------------------------------------------------------------------
Depending on the use case next to the \cpp{std::vector} container, the \cpp{std::list} container is available. The \cpp{std::list} container is provided by the \cpp{#include <list>} header. The usage of this container is similar to the \cpp{std::vector} and one can just replace \cpp{std::vector} by \cpp{std::list} in the code. Therefore, we will not provide any source code example here, since you can just look on them in the previous section. Compared to other containers, \emph{e.g.}\ \cpp{std::vector}, the \cpp{std::list} is designed for
\begin{enumerate}
\item Are slower for small amount of elements, and
\item Are optimized to insert and delete elements anywhere.
\end{enumerate}
For example the complexity for inserting or removing an element in a vector is $\mathcal{O}(n^2)$ and for the container \cpp{std::list} the complexity is $\mathcal{O}(n)$~\cite{michalewicz2013genetic,knuth1997art}.

%----------------------------------------------------------------------------------------
\subsection{Array}
\index{array}
\index{STL!array}
%----------------------------------------------------------------------------------------
Another container is the \cpp{std::array} and it is provided by the \cpp{#include <array>} header\link{https://en.cppreference.com/w/cpp/container/array}. Note that the array keyword is also available as a language feature\link{https://en.cppreference.com/w/cpp/language/array}. The major difference is that the number of elements must be known at compile time and can not grow or shrink dynamically. Listing~\ref{code:array:language} shows the usage of the array as the language feature. In Line~2 the size of the array is defined using \cpp{size_t} type since the size of the array is always positive. In Line~5  the array with the name \cpp{array} is defined using \cpp{[size]} to specify its size and we use the keyword \cpp{double} to specify the type of the elements. In this case we have a array of five \cpp{double} values which are not initialized. In Line~8 the values of the array are initialized from one to five using \cpp{\{1,2,3,4,5\}}. Lines~11--14 show how use a \cpp{for} loop to overwrite the values assigned in Line~8 and print them to the standard output stream. In Line~17 we use the dereference operator \cpp{*} to access the first element of the array which is equivalent to \cpp{array[0]} to put the value $42$ at the first position.\\

After looking into the usage of the array provided by as language feature, we look into the container version. The basic concepts are similar, but the container version can be used within the algorithms of the STL library which is sometimes a neat feature. Listing~\ref{code:array:container} shows the usage of the container version. In Line~7 the array is initialized very similar as for the language version, but since the \cpp{std::array} is provided by the C++ Standard Template Library the template specialization \cpp{<int,3>} is needed, where the first argument defines the data type and the second one the length of the array. In Line~11 the array is sorted using the \cpp{sort} method which we used to sort a \cpp{std::vector} or \cpp{std::list}. Note that is is only possible with the container version. Another nice feature is the range-based \cpp{for} loop in Lines~14--15.


\begin{lstlisting}[language=C++,caption={Usage of arrays using the language keyword.\label{code:array:language}},float,floatplacement=tb]
//Define the length
size_t size = 6;

//Generate a double array of size 6
double array[size];

//Initializing 
double array = {1,2,3,4,5};

//Access all elements
for(size_t i = 0; i < size ; i++){
        array[i] = i*2;
        std::cout << array[i] << std::endl;
    }

//Access the first element
*array = 42;
std::cout << array[0] << std::endl;

\end{lstlisting}

\begin{lstlisting}[language=C++,caption={Usage of arrays as containers.\label{code:array:container}},float,floatplacement=tb]
#include <algorithm>
#include <array>

int main()
{

// generate and initialize the array
std::array<int, 3> array = {1, 2, 3};

// Sort the array
std::sort(array.begin(), array.end());

// Use the range-based loop to print the elements
for(const auto& s: array)
	std::cout << s << ' ';

return 0;
}
\end{lstlisting}







%----------------------------------------------------------------------------------------
\subsection{Iterators}
\label{ref:stl:iterators}
%----------------------------------------------------------------------------------------
Iterators\index{iterator} provided by the \lstinline|\#include<iterator>|\link{https://en.cppreference.com/w/cpp/header/iterator} header are pointing to some specific element, \emph{e.g.}\ \cpp{std::array} or \cpp{std::vector}, and provides some fast way to iterator over all elements in the range. As the example, we use the a vector \cpp{std::vector<int> v = \{1,2,3,4,5\};} and to access the first element \cpp{v.begin()}\link{https://www.cplusplus.com/reference/iterator/begin/} and to access the last element \cpp{v.end()}\link{https://www.cplusplus.com/reference/iterator/end/} is used. For the algorithms in the next Section, we use these for example to sort \cpp{std::sort(v.begin(),s.end(),std::greater<int>()}\link{https://en.cppreference.com/w/cpp/utility/functional/greater} from the largest to the lowest number. We can also use \cpp{v.next()}\link{http://www.cplusplus.com/reference/iterator/next/} to get the next element and \cpp{v.prev()}\link{http://www.cplusplus.com/reference/iterator/prev/} to get the previous element.\\

Using iterators, we can do advanced iterating over vectors, see Listing~\ref{code:for:iterator}. In Line~9 a constant iterator \cpp{std::vector<int>::const_iter} and assign the first element of the vector to it. For the \cpp{for} loop in Section~\ref{sec:iteration:statements} this would be equivalent to loop variable \cpp{size_t i = 0}. In Line~11 we use the not equal operator \cpp{iter != values.end()} as the condition statement. The equivalent for the \cpp{for} loop would be \cpp{ i < vector.size()}. In~12 the manipulation statement \cpp{++iter} is used and for the \cpp{for} loop we would use \cpp{i++}.To get the content of the vector, we use the deference operator \cpp{*iter}. Note for the \cpp{for} loop we would use \cpp{values[i]}.\\

With the iterators erasing elements gets easier, since we can use the expression \cpp{values.erase(iter)}\link{https://en.cppreference.com/w/cpp/string/basic_string/erase} instead of \cpp{vlaues.erase(values.begin()+i)}. Note that the \cpp{erase} function returns the iterator of the element the iterator is pointing to after the deletion \cpp{iter = vlaues.erase(iter)} which is useful for some algorithms.

\lstinputlisting[language=C++,caption={Printing a vector using iterators.\label{code:for:iterator}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture3-for-iterator.cpp}



%----------------------------------------------------------------------------------------
\section{Algorithms}
\index{STL!algorithms}
\index{algorithms}
\label{sec:stl:algorithms}
%----------------------------------------------------------------------------------------
In this section some of the algorithms provided by the STL are studied. For a complete list of all available algorithms we refer to\link{https://en.cppreference.com/w/cpp/algorithm}. The median for a sorted list of numbers $\mathbf{v}=\{v_i \vert i =1,\ldots,n\}$ is given as
\begin{align}
median = \begin{cases}
v[\frac{n}{2}] \text{ if } n \text{ is even} \\
\frac{1}{2}\left( v[\frac{n}{2}] + v[\frac{n}{2}-1] \right) \text{else}
\end{cases} \text{.}
\end{align}
To compute the median of a \cpp{std::vector}, we have to sort the vector first. The STL provides the \cpp{std::sort} algorithm in the \cpp{#include <algorithm>} header. Listings~\ref{code:median} shows the computation of the median using the STL. In Line~6 a new feature \cpp{typedef}\link{https://en.cppreference.com/w/cpp/language/typedef} to shorten long lines of codes is introduced. In that case we do not want to type each time \cpp{std::vector<double>:: size_type} to get the data type of the vector size and want to use \cpp{vec_sz} instead. Each time the compiler recognizes \cpp{vec_sz} it will replace it by the long form. This is a neat feature to make the code more readable.\\

Line~13 shows how to use sort the values stored in the \cpp{std::vector} in Line~9--12. one has to provide the range of the vector to the sort function. Note that the current values in the vector will be replaced by the sorted ones. To keep the unsorted valued, a copy of the vector can be obtained by the \cpp{std::copy}\link{https://en.cppreference.com/w/cpp/algorithm/copy} algorithm.\\

\lstinputlisting[language=C++,caption={Computation of the median using the sorting algorithm provided by the STL.\label{code:median}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture2-median.cpp}

Another example is to compute the sum of all elements of a \cpp{std::vector} using a \cpp{for} loop or using the \cpp{std::accumulate}\link{https://en.cppreference.com/w/cpp/algorithm/accumulate} provided by the \cpp{#include <numerics>}\link{https://en.cppreference.com/w/cpp/header/numeric} header. Listing~\ref{code:algorithms:showcase} shows how to compute the sum and some neat algorithms. To fill a vector with the values one to ten, the function \cpp{std::ito}\link{https://en.cppreference.com/w/cpp/algorithm/iota} in Line~8 is used instead of writing a for loop. In Line~12--13 the sum is computed using the loop and in Line~17 the sum computed using the STL. One can easily see that the code in Line~17 is shorter and easier to understand. Therefore, it is recommended to use the STL were possible. In line~25--29 the values of the vector are printed to the standard output stream using a \cpp{for} loop. In Line~32 instead of using the \cpp{for} loop, the expression \cpp{std::for_each}\link{https://en.cppreference.com/w/cpp/algorithm/for_each} provided by the \cpp{#include <algorithm>} header is used. This lien of code iterates over all elements in the vector and call the function \cpp{print} and passes each element to the function. Note that the function can have only one argument and its type has to match the type of the vector.\\

There are many more algorithms in the STL as shown here. These algorithms will be introduced in the reaming parts of the book, especially with the numerical examples in Chapter~\ref{part:numerical:examples}. We recommend to have a look in the algorithms to write more efficient and less confusing code. For more details we refer to~\cite[Chapter~6]{andrew2000accelerated}.   


\begin{lstlisting}[language=c++,caption={Example for a function definition to compute the maximum of two numbers.\label{code:algorithms:showcase}},float,floatplacement=tbp]
#include <vector> 
#include <iostream>
#include <numerics>
#include <algorithm>

void print(double v){
	std::cout << v << " ";
}

int main(){

std::vector<double> values (10);
std::iota(values.begin(), values.end(), 1);

//Compute the sum using a for loop
double sum = 0;
for( auto& v : values)
	sum += v;
std::cout << "Sum:" << sum << std::endl;

//Compute the sum using STL 
sum = std::accumulate((values.begin(), values.end(),0);
std::cout << "Sum:" << sum << std::endl;

//Check the result by printing the vector using a for loop
for( size_t i = 0 ; i < values.size(); i++)
	std::cout << values[i] << " ";
	std::cout << std::endl;

}

//Check the result by printing the vector using STL
std::for_each(values.begin(), values.end(), print);
\end{lstlisting}



%----------------------------------------------------------------------------------------
\section{Parallel Algorithms}
\index{algorithms!parallel}
\index{parallel algorithms}
\index{STL!parallel algorithms}
\label{sec:stl:parallel:algorithms}
%----------------------------------------------------------------------------------------
Since the C++17 standard the parallel algorithm are specified. Currently, only the GNU compiler collection 9 and the MS Visual Studio compiler 19.14\link{https://en.cppreference.com/w/cpp/compiler_support} implement this as an experimental feature. 69 of the algorithms from the \cpp{#include <algorithm>}, \cpp{#include <numeric>}, and \cpp{#include <memory>} are available\link{https://en.cppreference.com/w/cpp/experimental/parallelism}. Note that this is an experimental feature and following compiler flags have to be added \bash{-std=c++1z} to use the experimental features and \bash{-lttb} to use the Threading Building Blocks (TTB) library\link{https://github.com/oneapi-src/oneTBB} for the parallel execution. Listing~\ref{code:parallel:algorithms} shows one example how to compute the sum over a vector in sequential and parallel.\\

In Line~4 the \cpp{#include <chrono>} header\link{https://en.cppreference.com/w/cpp/chrono} which is needed for time measurements\index{time measurements}. In Line~14 a timer \cpp{t1} is generated by using the expression \cpp{std::chrono::high_resolution_clock::now();}\link{https://en.cppreference.com/w/cpp/chrono/high_resolution_clock}. After this line of code is executed the current time is stored in the timer \cpp{t1}. In Line~16 after the line of code, we wanted to measure the execution time, a second timer \cpp{t2} is generated with the current time after Line~15 was executed. In Line~17 the difference between the two timers is computed by the expression \cpp{std::chrono::duration<double, std::milli> ms = t2 - t1;}\link{https://en.cppreference.com/w/cpp/chrono/duration}. Wit the second argument the unit is specified and in that case \cpp{std::milli}\link{https://en.cppreference.com/w/cpp/numeric/ratio/ratio} return the time difference in milliseconds. In Line~18 the expression \cpp{std::fixed}\link{https://en.cppreference.com/w/cpp/io/manip/fixed} restricts the number of decimal points printed.\\

Note that in Line~15 the expression \cpp{std::accumulate} is used to compute the sum of the elements of vector \cpp{nums} in a sequential manner. Meaning only one element is added up each time. For a large amount of elements this can be very time consuming. To make the computation of the sum more efficient, the parallel version of the algorithm can be used. Note that in the parallel algorithms the name of the algorithm is \cpp{std::reduce}\link{https://en.cppreference.com/w/cpp/experimental/reduce} and not \cpp{std::accumulate}. For the parallel algorithms the function parameters are identical, however, there is one additional parameter, the so-called execution policy\index{execution policy}, which is placed in front to the function parameters. In our case the \cpp{std::execution::par}\link{https://en.cppreference.com/w/cpp/experimental/execution_policy_tag} execution policy. With this execution policy\index{STL!execution policy} the code is executed using all threads of the hardware. Currently, the feature to specify the amount of threads is currently not implemented. To execute the same lien of code in a sequential manner the execution policy \cpp{std::execution::seq} is used. The header \cpp{#include <execution>} is necessary. Following execution policies are available:
\begin{itemize}
\item \lstinline|std::execution::seq| \\
The algorithm is executed sequential, like \lstinline|std::accumulate| in the previous example and using only once thread.
\item \lstinline|std::execution::par| \\
The algorithm is executed in parallel and used multiple threads.
\item \lstinline| std::execution::par_unseq| \\
The algorithm is executed in parallel and vectorization is used.
\end{itemize}
Fore more details, we refer to the talk ``The C++17 Parallel Algorithms Library and
Beyond''\link{https://www.youtube.com/watch?v=Vck6kzWjY88} at CppCon 2016. Listing~\ref{code:parallel:compile} shows how to compile the code using the experimental feature and some time measurements.


\lstinputlisting[language=C++,caption={Computation of the median using the sorting algorithm provided by the STL.\label{code:parallel:algorithms}},float,floatplacement=tbp]{ParallelComputationMathExamples/chapter2/lecture6-loops.cpp}


\begin{lstlisting}[language=bash,caption={Compilation of the parallel algorithm example.\label{code:parallel:compile}},float,floatplacement=tb]
g++ -std=c++1z -ltbb lecture6-loops.cpp 
./a.out
std::accumulate result 9e+08 took 10370.689498 ms
std::reduce result 9.000000e+08 took 612.173647 ms
\end{lstlisting}


\newpage
\theendnotes
